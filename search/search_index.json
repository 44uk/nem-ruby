{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Ruby gem for communicating with the nem. For further development of nem with ruby, feel free to send me your feedback! Installation $ gem install nem-ruby or add this line to your application's Gemfile. gem 'nem-ruby' Connection require 'pp' require 'nem' # connect to remote node node = Nem::Node.new(host: 'bigalice2.nem.ninja') # ENV['NEM_URL'] can be used if it set. # export NEM_URL=http://bigalice2.nem.ninja:7890 node = Nem::Node.new # connect to local node if no params node = Nem::Node.new # passing options node = Nem::Node.new(host: '127.0.0.1', port: 7890) # passing url node = Nem::Node.new(url: 'http://127.0.0.1:7890') You can pick node from NEM Node Rewards . Node Pool # create node pool node = Nem::NodePool.new([ Nem::Node.new(host: 'dummy1.example.com'), Nem::Node.new(host: 'dummy2.example.com'), Nem::Node.new(host: 'bigalice2.nem.ninja') ]) Endpoint endpoint = Nem::Endpoint::Account.new(node) pp endpoint.find('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') # Nem::Model::Account:0x007fca1b101070 # @address= TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4 , # @balance=68000000, # @cosignatories=[], # @cosignatory_of=[], # @harvested_blocks=1, # @importance=0.0, # @label=nil, # @public_key= e59ef184a612d4c3c4d89b5950eb57262c69862b2f96e59c5043bf41765c482f , # @remote_status= INACTIVE , # @status= LOCKED , # @vested_balance=62145647 # Node node.heartbeat # Nem::Model::Heartbeat:0x007f83d3b6eb68 @code=1, @message= ok , @type=2 # See https://nemproject.github.io/#heart-beat-request node.status # Nem::Model::Status:0x007f83d3b54920 @code=6, @message= status , @type=4 # See https://nemproject.github.io/#status-request calling API Path Also call Nem::Node#request method. The method receive HTTP Method , API Path , Parameters It returns hash which converted API JSON response. by API path /heartbeat, /status See NEM NIS API Documentation . pp node.request :get, 'heartbeat' pp node.request :get, 'status' pp node.request :get, 'account/get', address: 'TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4' pp node.request :post, 'account/unlock', privateKey: '00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda' Logging # custom loggin output (default is STDOUT) Nem.logger = Logger.new('/path/to/nem-ruby.log') # turn on output request information. Nem.logger.level = Logger::DEBUG # also set condig this way. Nem.configure do |conf| conf.logger = Logger.new('./nem-ruby.log') conf.logger.level = Logger::DEBUG # you can set deadline(sec) conf.default_deadline = 7200 # set :mainnet if you'd like to use on mainnet(default :testnet) conf.default_network = :mainnet end Output D, [2017-09-26T08:03:54.752718 #78207] DEBUG -- : host:http://127.0.0.1:7890/ method:post path:/transaction/prepare-announce params:{:transaction= {:type= 257, :network= :testnet, :recipient= TA4TX6U5HG2MROAESH2JE5524T4ZOY2EQKQ6ELHF , :amount= 1000000, :message= {:payload= 476f6f64206c75636b21 , :type= 1}, :fee= 100000, :timeStamp= 78793049, :deadline= 78796649, :version= 2550136833, :signer= be2ba9cb15a547110d511a4d43c0482fbb584d78781abac01fb053d18f4a0033 }, :privateKey= 4ce5c8f9fce571db0d9ac1adf00b8d3ba0f078ed40835fd3d730a2f24b834214 } Examples More specific example codes are in examples/ directory. XEM for development You can get Testnet XEM for development / testing from these faucet or thread. NEM Testnet Faucet - You can get Testnet XEM for development / testing. NEM TESTNET faucet\u301c\u3066\u3059\u3068\u306d\u3063\u3068\u86c7\u53e3\u301c NEM testnet Faucet Paste you address here for beta NEM (Testnet XEM) - Technical Discussion - NEM Forum Rubydoc Documentation for nem-ruby - rubydoc.info","title":"Home"},{"location":"#introduction","text":"Ruby gem for communicating with the nem. For further development of nem with ruby, feel free to send me your feedback!","title":"Introduction"},{"location":"#installation","text":"$ gem install nem-ruby or add this line to your application's Gemfile. gem 'nem-ruby'","title":"Installation"},{"location":"#connection","text":"require 'pp' require 'nem' # connect to remote node node = Nem::Node.new(host: 'bigalice2.nem.ninja') # ENV['NEM_URL'] can be used if it set. # export NEM_URL=http://bigalice2.nem.ninja:7890 node = Nem::Node.new # connect to local node if no params node = Nem::Node.new # passing options node = Nem::Node.new(host: '127.0.0.1', port: 7890) # passing url node = Nem::Node.new(url: 'http://127.0.0.1:7890') You can pick node from NEM Node Rewards .","title":"Connection"},{"location":"#node-pool","text":"# create node pool node = Nem::NodePool.new([ Nem::Node.new(host: 'dummy1.example.com'), Nem::Node.new(host: 'dummy2.example.com'), Nem::Node.new(host: 'bigalice2.nem.ninja') ])","title":"Node Pool"},{"location":"#endpoint","text":"endpoint = Nem::Endpoint::Account.new(node) pp endpoint.find('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') # Nem::Model::Account:0x007fca1b101070 # @address= TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4 , # @balance=68000000, # @cosignatories=[], # @cosignatory_of=[], # @harvested_blocks=1, # @importance=0.0, # @label=nil, # @public_key= e59ef184a612d4c3c4d89b5950eb57262c69862b2f96e59c5043bf41765c482f , # @remote_status= INACTIVE , # @status= LOCKED , # @vested_balance=62145647 #","title":"Endpoint"},{"location":"#node","text":"node.heartbeat # Nem::Model::Heartbeat:0x007f83d3b6eb68 @code=1, @message= ok , @type=2 # See https://nemproject.github.io/#heart-beat-request node.status # Nem::Model::Status:0x007f83d3b54920 @code=6, @message= status , @type=4 # See https://nemproject.github.io/#status-request","title":"Node"},{"location":"#calling-api-path","text":"Also call Nem::Node#request method. The method receive HTTP Method , API Path , Parameters It returns hash which converted API JSON response. by API path /heartbeat, /status See NEM NIS API Documentation . pp node.request :get, 'heartbeat' pp node.request :get, 'status' pp node.request :get, 'account/get', address: 'TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4' pp node.request :post, 'account/unlock', privateKey: '00983bb01d05edecfaef55df9486c111abb6299c754a002069b1d0ef4537441bda'","title":"calling API Path"},{"location":"#logging","text":"# custom loggin output (default is STDOUT) Nem.logger = Logger.new('/path/to/nem-ruby.log') # turn on output request information. Nem.logger.level = Logger::DEBUG # also set condig this way. Nem.configure do |conf| conf.logger = Logger.new('./nem-ruby.log') conf.logger.level = Logger::DEBUG # you can set deadline(sec) conf.default_deadline = 7200 # set :mainnet if you'd like to use on mainnet(default :testnet) conf.default_network = :mainnet end","title":"Logging"},{"location":"#output","text":"D, [2017-09-26T08:03:54.752718 #78207] DEBUG -- : host:http://127.0.0.1:7890/ method:post path:/transaction/prepare-announce params:{:transaction= {:type= 257, :network= :testnet, :recipient= TA4TX6U5HG2MROAESH2JE5524T4ZOY2EQKQ6ELHF , :amount= 1000000, :message= {:payload= 476f6f64206c75636b21 , :type= 1}, :fee= 100000, :timeStamp= 78793049, :deadline= 78796649, :version= 2550136833, :signer= be2ba9cb15a547110d511a4d43c0482fbb584d78781abac01fb053d18f4a0033 }, :privateKey= 4ce5c8f9fce571db0d9ac1adf00b8d3ba0f078ed40835fd3d730a2f24b834214 }","title":"Output"},{"location":"#examples","text":"More specific example codes are in examples/ directory.","title":"Examples"},{"location":"#xem-for-development","text":"You can get Testnet XEM for development / testing from these faucet or thread. NEM Testnet Faucet - You can get Testnet XEM for development / testing. NEM TESTNET faucet\u301c\u3066\u3059\u3068\u306d\u3063\u3068\u86c7\u53e3\u301c NEM testnet Faucet Paste you address here for beta NEM (Testnet XEM) - Technical Discussion - NEM Forum","title":"XEM for development"},{"location":"#rubydoc","text":"Documentation for nem-ruby - rubydoc.info","title":"Rubydoc"},{"location":"about/","text":"Feedback and Contact For further development of nem with ruby, feel free to send me your feedback, feature requests, bug reports! 44uk/nem-ruby - gitter @44uk_i3 - Twitter and I would be glad if you could let me know any project using the gem! Donation The project gratefully accepts donations via nem:xem. NCPBJTNKHODIGPDMPKPETJK6YLMUPAW7ISBIQGUP Thanks NEM - Distributed Ledger Technology (Blockchain) NEM NIS API Documentation NEM Forum Contributing Bug reports and pull requests are welcome on GitHub at 44uk/nem-ruby . This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the Contributor Covenant code of conduct. License The gem is available as open source under the terms of the MIT License .","title":"About"},{"location":"about/#feedback-and-contact","text":"For further development of nem with ruby, feel free to send me your feedback, feature requests, bug reports! 44uk/nem-ruby - gitter @44uk_i3 - Twitter and I would be glad if you could let me know any project using the gem!","title":"Feedback and Contact"},{"location":"about/#donation","text":"The project gratefully accepts donations via nem:xem. NCPBJTNKHODIGPDMPKPETJK6YLMUPAW7ISBIQGUP","title":"Donation"},{"location":"about/#thanks","text":"NEM - Distributed Ledger Technology (Blockchain) NEM NIS API Documentation NEM Forum","title":"Thanks"},{"location":"about/#contributing","text":"Bug reports and pull requests are welcome on GitHub at 44uk/nem-ruby . This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the Contributor Covenant code of conduct.","title":"Contributing"},{"location":"about/#license","text":"The gem is available as open source under the terms of the MIT License .","title":"License"},{"location":"mosaic/","text":"Mosaic attachment definition class MyMosaic include Nem::Mixin::MosaicAttachable namespace_id 'my' name 'moz' divisibility 3 initial_supply 1_234_567_890 end Build-in Mosaic definitions Nem::Mosaic::ComsaCms Nem::Mosaic::DimCoin Nem::Mosaic::DimToken Nem::Mosaic::EcobitEco Nem::Mosaic::PondixPxs Nem::Mosaic::QchainXqc Nem::Mosaic::Xem","title":"Mosaic"},{"location":"mosaic/#mosaic-attachment-definition","text":"class MyMosaic include Nem::Mixin::MosaicAttachable namespace_id 'my' name 'moz' divisibility 3 initial_supply 1_234_567_890 end","title":"Mosaic attachment definition"},{"location":"mosaic/#build-in-mosaic-definitions","text":"Nem::Mosaic::ComsaCms Nem::Mosaic::DimCoin Nem::Mosaic::DimToken Nem::Mosaic::EcobitEco Nem::Mosaic::PondixPxs Nem::Mosaic::QchainXqc Nem::Mosaic::Xem","title":"Build-in Mosaic definitions"},{"location":"examples/account/","text":"Endpoint node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Account.new(node) Find Address # find by address pp endpoint.find('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') # alias pp endpoint.get('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') # find by public key pp endpoint.find_by_public_key('e59ef184a612d4c3c4d89b5950eb57262c69862b2f96e59c5043bf41765c482f') # find forwarded by address pp endpoint.find_forwarded('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') # find forwarded by public key pp endpoint.find_forwarded_by_public_key('e59ef184a612d4c3c4d89b5950eb57262c69862b2f96e59c5043bf41765c482f') Hervests pp endpoint.harvests('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') Namespace / Mosaics # namespace pp endpoint.namespace('TDPICOQ7GIEMIDJOOMIQSOYIJKG3C7V7OP2DUFIR') # fetch mosaic definition of account pp endpoint.mosaic_definition('TDPICOQ7GIEMIDJOOMIQSOYIJKG3C7V7OP2DUFIR') # fetch owned mosaics of account mosaics = account_endpoint.mosaic_owned('TDPICOQ7GIEMIDJOOMIQSOYIJKG3C7V7OP2DUFIR') pp mosaics ## can find by namespace pp mosaics.find_by_namespace_id('tpico') ## can find by fqn pp mosaics.find_by_fqn('tpico:test') Transactions ## incomings pp endpoint.transfers_incoming('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') ## outgoings pp endpoint.transfers_outgoing('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') ## all pp endpoint.transfers_all('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') ## unconfirmed pp endpoint.transfers_unconfirmed('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') Status pp endpoint.status('TDJNDAQ7F7AQRXKP2YVTH67QYCWWKE6QLSJFWN64') Unlocked pp endpoint.unlocked_info Historical pp endpoint.historical('TDWWYDGQNBKSAJBSHZX7QWVX7WNVAWWB7HGPWRB2', start_height: 1245390, end_height: 1245400, increment: 1 ) Generate Account / Lock, Unlock The APIs allowed only Local NIS. ## generate account pp endpoint.generate ## lock account pp endpoint.lock('__private_key__') ## unlock account pp endpoint.unlock('__private_key__')","title":"Account"},{"location":"examples/account/#endpoint","text":"node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Account.new(node)","title":"Endpoint"},{"location":"examples/account/#find-address","text":"# find by address pp endpoint.find('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') # alias pp endpoint.get('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') # find by public key pp endpoint.find_by_public_key('e59ef184a612d4c3c4d89b5950eb57262c69862b2f96e59c5043bf41765c482f') # find forwarded by address pp endpoint.find_forwarded('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') # find forwarded by public key pp endpoint.find_forwarded_by_public_key('e59ef184a612d4c3c4d89b5950eb57262c69862b2f96e59c5043bf41765c482f')","title":"Find Address"},{"location":"examples/account/#hervests","text":"pp endpoint.harvests('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4')","title":"Hervests"},{"location":"examples/account/#namespace-mosaics","text":"# namespace pp endpoint.namespace('TDPICOQ7GIEMIDJOOMIQSOYIJKG3C7V7OP2DUFIR') # fetch mosaic definition of account pp endpoint.mosaic_definition('TDPICOQ7GIEMIDJOOMIQSOYIJKG3C7V7OP2DUFIR') # fetch owned mosaics of account mosaics = account_endpoint.mosaic_owned('TDPICOQ7GIEMIDJOOMIQSOYIJKG3C7V7OP2DUFIR') pp mosaics ## can find by namespace pp mosaics.find_by_namespace_id('tpico') ## can find by fqn pp mosaics.find_by_fqn('tpico:test')","title":"Namespace / Mosaics"},{"location":"examples/account/#transactions","text":"## incomings pp endpoint.transfers_incoming('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') ## outgoings pp endpoint.transfers_outgoing('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') ## all pp endpoint.transfers_all('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4') ## unconfirmed pp endpoint.transfers_unconfirmed('TBULEAUG2CZQISUR442HWA6UAKGWIXHDABJVIPS4')","title":"Transactions"},{"location":"examples/account/#status","text":"pp endpoint.status('TDJNDAQ7F7AQRXKP2YVTH67QYCWWKE6QLSJFWN64')","title":"Status"},{"location":"examples/account/#unlocked","text":"pp endpoint.unlocked_info","title":"Unlocked"},{"location":"examples/account/#historical","text":"pp endpoint.historical('TDWWYDGQNBKSAJBSHZX7QWVX7WNVAWWB7HGPWRB2', start_height: 1245390, end_height: 1245400, increment: 1 )","title":"Historical"},{"location":"examples/account/#generate-account-lock-unlock","text":"The APIs allowed only Local NIS. ## generate account pp endpoint.generate ## lock account pp endpoint.lock('__private_key__') ## unlock account pp endpoint.unlock('__private_key__')","title":"Generate Account / Lock, Unlock"},{"location":"examples/apostille/","text":"Public Apostille Create require 'pp' require 'nem' FIXTURES_PATH = File.expand_path('../../spec/fixtures', __FILE__) # sender A_PRIVATE_KEY = '4ce5c8f9fce571db0d9ac1adf00b8d3ba0f078ed40835fd3d730a2f24b834214' kp = Nem::Keypair.new(A_PRIVATE_KEY) node = Nem::Node.new(host: 'bigalice2.nem.ninja') tx_endpoint = Nem::Endpoint::Transaction.new(node) file = File.open( #{FIXTURES_PATH}/nemLogoV2.png ) apo = Nem::Apostille.new(kp, file, :sha1, multisig: false, signed: false, network: :testnet ) tx = apo.transaction pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = tx_endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} pp ApostilleFormat: #{apo.apostille_format(res.transaction_hash)} FileUtils.cp(file.path, apo.apostille_format(res.transaction_hash)) Audit require 'pp' require 'nem' node = Nem::Node.new(host: 'bigalice2.nem.ninja') tx_endpoint = Nem::Endpoint::Transaction.new(node) # transaction hash from Filename tx_hash = 'c035c2603356852687c4730fbc6f8d21da3af7c4c0eb8b3619bc9ecdc833255a' tx = tx_endpoint.find(tx_hash) # NOTE: it may return Hash was not found in cache # because of NIS not supporting caching transactions. # 'fe4e545902cde315617a435ebfd5fe8875d699e2f2363262f5' apostille_hash = tx.message.payload file = File.open( #{FIXTURES_PATH}/nemLogoV2 -- Apostille TX c035c2603356852687c4730fbc6f8d21da3af7c4c0eb8b3619bc9ecdc833255a -- Date 2017-12-18.png ) apa = Nem::ApostilleAudit.new(file, apostille_hash) pp apa.valid? ? 'OK, Valid Apostille!' : 'Bad, Invalid Apostille!'","title":"Apostille"},{"location":"examples/apostille/#public-apostille","text":"","title":"Public Apostille"},{"location":"examples/apostille/#create","text":"require 'pp' require 'nem' FIXTURES_PATH = File.expand_path('../../spec/fixtures', __FILE__) # sender A_PRIVATE_KEY = '4ce5c8f9fce571db0d9ac1adf00b8d3ba0f078ed40835fd3d730a2f24b834214' kp = Nem::Keypair.new(A_PRIVATE_KEY) node = Nem::Node.new(host: 'bigalice2.nem.ninja') tx_endpoint = Nem::Endpoint::Transaction.new(node) file = File.open( #{FIXTURES_PATH}/nemLogoV2.png ) apo = Nem::Apostille.new(kp, file, :sha1, multisig: false, signed: false, network: :testnet ) tx = apo.transaction pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = tx_endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} pp ApostilleFormat: #{apo.apostille_format(res.transaction_hash)} FileUtils.cp(file.path, apo.apostille_format(res.transaction_hash))","title":"Create"},{"location":"examples/apostille/#audit","text":"require 'pp' require 'nem' node = Nem::Node.new(host: 'bigalice2.nem.ninja') tx_endpoint = Nem::Endpoint::Transaction.new(node) # transaction hash from Filename tx_hash = 'c035c2603356852687c4730fbc6f8d21da3af7c4c0eb8b3619bc9ecdc833255a' tx = tx_endpoint.find(tx_hash) # NOTE: it may return Hash was not found in cache # because of NIS not supporting caching transactions. # 'fe4e545902cde315617a435ebfd5fe8875d699e2f2363262f5' apostille_hash = tx.message.payload file = File.open( #{FIXTURES_PATH}/nemLogoV2 -- Apostille TX c035c2603356852687c4730fbc6f8d21da3af7c4c0eb8b3619bc9ecdc833255a -- Date 2017-12-18.png ) apa = Nem::ApostilleAudit.new(file, apostille_hash) pp apa.valid? ? 'OK, Valid Apostille!' : 'Bad, Invalid Apostille!'","title":"Audit"},{"location":"examples/block/","text":"Endpoint node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Account.new(node) at public pp endpoint.at_public(1_223_559)","title":"Block"},{"location":"examples/block/#endpoint","text":"node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Account.new(node)","title":"Endpoint"},{"location":"examples/block/#at-public","text":"pp endpoint.at_public(1_223_559)","title":"at public"},{"location":"examples/chain/","text":"Endpoint node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Chain.new(node) height pp endpoint.height score pp endpoint.score last block pp endpoint.last_block","title":"Chain"},{"location":"examples/chain/#endpoint","text":"node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Chain.new(node)","title":"Endpoint"},{"location":"examples/chain/#height","text":"pp endpoint.height","title":"height"},{"location":"examples/chain/#score","text":"pp endpoint.score","title":"score"},{"location":"examples/chain/#last-block","text":"pp endpoint.last_block","title":"last block"},{"location":"examples/configure/","text":"Configuration Nem.configure do |conf| # output path conf.logger = Logger.new('./nem-ruby.log') # logger level conf.logger.level = Logger::DEBUG # output debug log conf.debug = true # deadline(sec) conf.default_deadline = 7200 # :mainnet if you'd like to use on mainnet! conf.default_network = :mainnet end","title":"Configure"},{"location":"examples/configure/#configuration","text":"Nem.configure do |conf| # output path conf.logger = Logger.new('./nem-ruby.log') # logger level conf.logger.level = Logger::DEBUG # output debug log conf.debug = true # deadline(sec) conf.default_deadline = 7200 # :mainnet if you'd like to use on mainnet! conf.default_network = :mainnet end","title":"Configuration"},{"location":"examples/debug/","text":"Endpoint node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Debug.new(node) connections # mapped methods pp endpoint.connections_incoming pp endpoint.connections_outgoing pp endpoint.connections_timers # another way pp endpoint.debug_connections(:in) pp endpoint.debug_connections(:out) time synchronization pp endpoint.time_synchronization","title":"Debug"},{"location":"examples/debug/#endpoint","text":"node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Debug.new(node)","title":"Endpoint"},{"location":"examples/debug/#connections","text":"# mapped methods pp endpoint.connections_incoming pp endpoint.connections_outgoing pp endpoint.connections_timers # another way pp endpoint.debug_connections(:in) pp endpoint.debug_connections(:out)","title":"connections"},{"location":"examples/debug/#time-synchronization","text":"pp endpoint.time_synchronization","title":"time synchronization"},{"location":"examples/define_mosaic_attachment/","text":"Mosaic attachment definition class MyMosaic include Nem::Mixin::MosaicAttachable namespace_id 'my' name 'moz' divisibility 3 initial_supply 1_234_567_890 end","title":"Define mosaic attachment"},{"location":"examples/define_mosaic_attachment/#mosaic-attachment-definition","text":"class MyMosaic include Nem::Mixin::MosaicAttachable namespace_id 'my' name 'moz' divisibility 3 initial_supply 1_234_567_890 end","title":"Mosaic attachment definition"},{"location":"examples/local/","text":"Endpoint node = Nem::Node.new endpoint = Nem::Endpoint::Local.new(node) account transfers value = '00b4a68d16dc505302e9631b860664ba43a8183f0903bc5782a2403b2f9eb3c8a1' # mapped methods pp endpoint.transfers_incoming(value) pp endpoint.transfers_outgoing(value) pp endpoint.transfers_all(value) # another way pp endpoint.transfers(value, :in) pp endpoint.transfers(value, :out) pp endpoint.transfers(value, :all) chain blocks after pp endpoint.blocks_after(1_223_559)","title":"Local"},{"location":"examples/local/#endpoint","text":"node = Nem::Node.new endpoint = Nem::Endpoint::Local.new(node)","title":"Endpoint"},{"location":"examples/local/#account-transfers","text":"value = '00b4a68d16dc505302e9631b860664ba43a8183f0903bc5782a2403b2f9eb3c8a1' # mapped methods pp endpoint.transfers_incoming(value) pp endpoint.transfers_outgoing(value) pp endpoint.transfers_all(value) # another way pp endpoint.transfers(value, :in) pp endpoint.transfers(value, :out) pp endpoint.transfers(value, :all)","title":"account transfers"},{"location":"examples/local/#chain-blocks-after","text":"pp endpoint.blocks_after(1_223_559)","title":"chain blocks after"},{"location":"examples/mosaic/","text":"Endpoint node = Nem::Node.new endpoint = Nem::Endpoint::Mosaic.new(node) supply pp mo_endpoint.supply('nembar:vip')","title":"Mosaic"},{"location":"examples/mosaic/#endpoint","text":"node = Nem::Node.new endpoint = Nem::Endpoint::Mosaic.new(node)","title":"Endpoint"},{"location":"examples/mosaic/#supply","text":"pp mo_endpoint.supply('nembar:vip')","title":"supply"},{"location":"examples/namespace/","text":"Endpoint node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Namespace.new(node) find pp ns_endpoint.find('alice') root pp ns_endpoint.root(882, page_size: 1) mosaic definition page pp ns_endpoint.mosaic_definition('tpico')","title":"Namespace"},{"location":"examples/namespace/#endpoint","text":"node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Namespace.new(node)","title":"Endpoint"},{"location":"examples/namespace/#find","text":"pp ns_endpoint.find('alice')","title":"find"},{"location":"examples/namespace/#root","text":"pp ns_endpoint.root(882, page_size: 1)","title":"root"},{"location":"examples/namespace/#mosaic-definition-page","text":"pp ns_endpoint.mosaic_definition('tpico')","title":"mosaic definition page"},{"location":"examples/nis/","text":"Node node = Nem::Node.new(host: 'bigalice2.nem.ninja') heartbeat pp node.heartbeat # passing API Path pp node.request :get, 'heartbeat' status pp node.status # passing API Path pp node.request :get, 'status'","title":"Nis"},{"location":"examples/nis/#node","text":"node = Nem::Node.new(host: 'bigalice2.nem.ninja')","title":"Node"},{"location":"examples/nis/#heartbeat","text":"pp node.heartbeat # passing API Path pp node.request :get, 'heartbeat'","title":"heartbeat"},{"location":"examples/nis/#status","text":"pp node.status # passing API Path pp node.request :get, 'status'","title":"status"},{"location":"examples/node/","text":"Endpoint node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Node.new(node) Info pp endpoint.node_info pp endpoint.node_extended_info pp endpoint.node_experiences Peerlist # mapped methods pp endpoint.node_peerlist_all pp endpoint.node_peerlist_reachable pp endpoint.node_peerlist_active # another way pp endpoint.node_peerlist(:all) pp endpoint.node_peerlist(:reachable) pp endpoint.node_peerlist(:active) Active peers max chain height endpoint = node_endpoint = Nem::Endpoint::Node.new(Nem::Node.new) pp endpoint.node_active_peers_max_chain_height Boot node request bnr = Nis::Struct::BootNodeRequest.new( metaData: { application: 'NIS' }, endpoint: { protocol: 'http', port: 7890, host: 'localhost' }, identity: { 'private-key': 'a6cbd01d04edecfaef51df9486c111abb6299c764a00206eb1d01f4587491b3f', name: 'Alice' } ) begin pp endpoint.node_boot(boot_node_request: bnr) rescue = ex pp ex end","title":"Node"},{"location":"examples/node/#endpoint","text":"node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Node.new(node)","title":"Endpoint"},{"location":"examples/node/#info","text":"pp endpoint.node_info pp endpoint.node_extended_info pp endpoint.node_experiences","title":"Info"},{"location":"examples/node/#peerlist","text":"# mapped methods pp endpoint.node_peerlist_all pp endpoint.node_peerlist_reachable pp endpoint.node_peerlist_active # another way pp endpoint.node_peerlist(:all) pp endpoint.node_peerlist(:reachable) pp endpoint.node_peerlist(:active)","title":"Peerlist"},{"location":"examples/node/#active-peers-max-chain-height","text":"endpoint = node_endpoint = Nem::Endpoint::Node.new(Nem::Node.new) pp endpoint.node_active_peers_max_chain_height","title":"Active peers max chain height"},{"location":"examples/node/#boot-node-request","text":"bnr = Nis::Struct::BootNodeRequest.new( metaData: { application: 'NIS' }, endpoint: { protocol: 'http', port: 7890, host: 'localhost' }, identity: { 'private-key': 'a6cbd01d04edecfaef51df9486c111abb6299c764a00206eb1d01f4587491b3f', name: 'Alice' } ) begin pp endpoint.node_boot(boot_node_request: bnr) rescue = ex pp ex end","title":"Boot node request"},{"location":"examples/offline/","text":"Offline transaction Create signed transaction require 'pp' require 'nem' # sender A_PRIVATE_KEY = '4ce5c8f9fce571db0d9ac1adf00b8d3ba0f078ed40835fd3d730a2f24b834214' # recipient B_ADDRESS = 'TA4TX6U5HG2MROAESH2JE5524T4ZOY2EQKQ6ELHF' kp = Nem::Keypair.new(A_PRIVATE_KEY) tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck! Offline transfer.') req = Nem::Request::Announce.new(tx, kp) # signed announce pp data = req.to_entity pp 'save as tx.json' File.write 'tx.json', data.to_json Announce signed transaction require 'pp' require 'nem' node = Nem::Node.new(host: 'bigalice2.nem.ninja') tx_endpoint = Nem::Endpoint::Transaction.new(node) req = File.read('tx.json') res = tx_endpoint.announce(JSON.parse(req)) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Offline"},{"location":"examples/offline/#offline-transaction","text":"","title":"Offline transaction"},{"location":"examples/offline/#create-signed-transaction","text":"require 'pp' require 'nem' # sender A_PRIVATE_KEY = '4ce5c8f9fce571db0d9ac1adf00b8d3ba0f078ed40835fd3d730a2f24b834214' # recipient B_ADDRESS = 'TA4TX6U5HG2MROAESH2JE5524T4ZOY2EQKQ6ELHF' kp = Nem::Keypair.new(A_PRIVATE_KEY) tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck! Offline transfer.') req = Nem::Request::Announce.new(tx, kp) # signed announce pp data = req.to_entity pp 'save as tx.json' File.write 'tx.json', data.to_json","title":"Create signed transaction"},{"location":"examples/offline/#announce-signed-transaction","text":"require 'pp' require 'nem' node = Nem::Node.new(host: 'bigalice2.nem.ninja') tx_endpoint = Nem::Endpoint::Transaction.new(node) req = File.read('tx.json') res = tx_endpoint.announce(JSON.parse(req)) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Announce signed transaction"},{"location":"examples/timesync/","text":"Endpoint node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Timesync.new(node) Network time pp endpoint.network_time","title":"Timesync"},{"location":"examples/timesync/#endpoint","text":"node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Timesync.new(node)","title":"Endpoint"},{"location":"examples/timesync/#network-time","text":"pp endpoint.network_time","title":"Network time"},{"location":"examples/transactions/","text":"Endpoint node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Transaction.new(node) kp = Nem::Keypair.new(A_PRIVATE_KEY) Get Transaction pp endpoint.find('a7131c0836da45e72f61ac6e76259d7200a85f0d2cf38f79f223b2c366673b08') Transfer Version1(XEM transfer) tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck!') pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} Version2(mosaic transfer) tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck!') # define custom mosaic attachment if you already know mosaic definition class KonHeart include Nem::Mixin::MosaicAttachable namespace_id 'kon' name 'heart' divisibility 3 initial_supply 100_000_000 end tx.mosaics KonHeart.new(1) # fetch mosaic definition ns_endpoint = Nem::Endpoint::Namespace.new(node) mo_def = ns_endpoint.mosaic_definition('kon').first moa = Nem::Model::MosaicAttachment.new( mosaic_id: mo_def.id, properties: mo_def.properties, quantity: 1 ) tx.mosaics moa # send xem as mosaic tx.mosaics Nem::Mosaic::Xem.new(1) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} Importance Transfer tx = Nem::Transaction::ImportanceTransfer.new(B_PUBLIC_KEY, :activate) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} Multisig Signature account_endpoint = Nem::Endpoint::Account.new(node) txes = account_endpoint.transfers_unconfirmed(B_ADDRESS) unless txes.size 0 puts 'There are no transactions to sign.' exit end need_sig_tx = txes.first pp Unconfirmed Transaction Hash: #{need_sig_tx.hash} tx = Nem::Transaction::MultisigSignature.new(need_sig_tx.hash, M_ADDRESS, B_PUBLIC_KEY) req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} Provision Namespace tx = Nem::Transaction::ProvisionNamespace.new('sushi') pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} Mosaic Creation mosaic_id = Nem::Model::MosaicId.new( namespace_id: 'sushi', name: 'maguro' ) properties = Nem::Model::MosaicProperties.new( divisibility: 0, initial_supply: 10_000, supply_mutable: true, transferable: true ) levy = Nem::Model::MosaicLevy.new( type: 1, recipient: A_ADDRESS, mosaic_id: Nem::Model::MosaicId.new( namespace_id: 'nem', name: 'xem' ), fee: 1_000 ) definition = Nem::Model::MosaicDefinition.new( creator: A_PUBLIC_KEY, id: mosaic_id, description: 'Japanese Soul food SHUSHI.', properties: properties, levy: levy ) tx = Nem::Transaction::MosaicDefinitionCreation.new(definition) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} Supply Change mosaic_id = Nem::Model::MosaicId.new( namespace_id: 'sushi', name: 'maguro' ) tx = Nem::Transaction::MosaicSupplyChange.new(mosaic_id, :increase, 1_000) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = tx_endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} Multisig Aggregate Modification msig_cosignatories = [ Nem::Transaction::MultisigCosignatoryModification.new(:add, A_PUBLIC_KEY) ] relative_change = 1 tx = Nem::Transaction::MultisigAggregateModification.new(msig_cosignatories, relative_change) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} Add cosignatory msig_cosigratories = [ Nem::Transaction::MultisigCosignatoryModification.new(:add, B_PUBLIC_KEY) ] relative_change = 1 mtx = Nem::Transaction::MultisigAggregateModification.new(msig_cosigratories, relative_change) tx = Nem::Transaction::Multisig.new(mtx, M_PUBLIC_KEY) req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash} Local node tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck!') pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) # use #prepare_announce method for local node without signature res = endpoint.prepare_announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Transactions"},{"location":"examples/transactions/#endpoint","text":"node = Nem::Node.new(host: 'bigalice2.nem.ninja') endpoint = Nem::Endpoint::Transaction.new(node) kp = Nem::Keypair.new(A_PRIVATE_KEY)","title":"Endpoint"},{"location":"examples/transactions/#get-transaction","text":"pp endpoint.find('a7131c0836da45e72f61ac6e76259d7200a85f0d2cf38f79f223b2c366673b08')","title":"Get Transaction"},{"location":"examples/transactions/#transfer","text":"","title":"Transfer"},{"location":"examples/transactions/#version1xem-transfer","text":"tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck!') pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Version1(XEM transfer)"},{"location":"examples/transactions/#version2mosaic-transfer","text":"tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck!') # define custom mosaic attachment if you already know mosaic definition class KonHeart include Nem::Mixin::MosaicAttachable namespace_id 'kon' name 'heart' divisibility 3 initial_supply 100_000_000 end tx.mosaics KonHeart.new(1) # fetch mosaic definition ns_endpoint = Nem::Endpoint::Namespace.new(node) mo_def = ns_endpoint.mosaic_definition('kon').first moa = Nem::Model::MosaicAttachment.new( mosaic_id: mo_def.id, properties: mo_def.properties, quantity: 1 ) tx.mosaics moa # send xem as mosaic tx.mosaics Nem::Mosaic::Xem.new(1) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Version2(mosaic transfer)"},{"location":"examples/transactions/#importance-transfer","text":"tx = Nem::Transaction::ImportanceTransfer.new(B_PUBLIC_KEY, :activate) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Importance Transfer"},{"location":"examples/transactions/#multisig-signature","text":"account_endpoint = Nem::Endpoint::Account.new(node) txes = account_endpoint.transfers_unconfirmed(B_ADDRESS) unless txes.size 0 puts 'There are no transactions to sign.' exit end need_sig_tx = txes.first pp Unconfirmed Transaction Hash: #{need_sig_tx.hash} tx = Nem::Transaction::MultisigSignature.new(need_sig_tx.hash, M_ADDRESS, B_PUBLIC_KEY) req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Multisig Signature"},{"location":"examples/transactions/#provision-namespace","text":"tx = Nem::Transaction::ProvisionNamespace.new('sushi') pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Provision Namespace"},{"location":"examples/transactions/#mosaic","text":"","title":"Mosaic"},{"location":"examples/transactions/#creation","text":"mosaic_id = Nem::Model::MosaicId.new( namespace_id: 'sushi', name: 'maguro' ) properties = Nem::Model::MosaicProperties.new( divisibility: 0, initial_supply: 10_000, supply_mutable: true, transferable: true ) levy = Nem::Model::MosaicLevy.new( type: 1, recipient: A_ADDRESS, mosaic_id: Nem::Model::MosaicId.new( namespace_id: 'nem', name: 'xem' ), fee: 1_000 ) definition = Nem::Model::MosaicDefinition.new( creator: A_PUBLIC_KEY, id: mosaic_id, description: 'Japanese Soul food SHUSHI.', properties: properties, levy: levy ) tx = Nem::Transaction::MosaicDefinitionCreation.new(definition) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Creation"},{"location":"examples/transactions/#supply-change","text":"mosaic_id = Nem::Model::MosaicId.new( namespace_id: 'sushi', name: 'maguro' ) tx = Nem::Transaction::MosaicSupplyChange.new(mosaic_id, :increase, 1_000) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = tx_endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Supply Change"},{"location":"examples/transactions/#multisig-aggregate-modification","text":"msig_cosignatories = [ Nem::Transaction::MultisigCosignatoryModification.new(:add, A_PUBLIC_KEY) ] relative_change = 1 tx = Nem::Transaction::MultisigAggregateModification.new(msig_cosignatories, relative_change) pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Multisig Aggregate Modification"},{"location":"examples/transactions/#add-cosignatory","text":"msig_cosigratories = [ Nem::Transaction::MultisigCosignatoryModification.new(:add, B_PUBLIC_KEY) ] relative_change = 1 mtx = Nem::Transaction::MultisigAggregateModification.new(msig_cosigratories, relative_change) tx = Nem::Transaction::Multisig.new(mtx, M_PUBLIC_KEY) req = Nem::Request::Announce.new(tx, kp) res = endpoint.announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Add cosignatory"},{"location":"examples/transactions/#local-node","text":"tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck!') pp Fee: #{tx.fee.to_i} req = Nem::Request::Announce.new(tx, kp) # use #prepare_announce method for local node without signature res = endpoint.prepare_announce(req) pp Message: #{res.message} pp TransactionHash: #{res.transaction_hash}","title":"Local node"},{"location":"examples/util/","text":"Deserialize transaction require 'pp' require 'nem' # sender A_PRIVATE_KEY = '260206d683962350532408e8774fd14870a173b7fba17f6b504da3dbc5f1cc9f' # receiver B_ADDRESS = 'TAWKJTUP4DWKLDKKS534TYP6G324CBNMXKBA4X7B' kp = Nem::Keypair.new(A_PRIVATE_KEY) tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck!') req = Nem::Request::Announce.new(tx, kp) data = req.to_entity[:data] # You can also announce to nem Network later. pp data # deserialize data into hash hash = Nem::Util::Deserializer.deserialize(data) pp Nem::Model::Transaction.new_from_account_transaction(hash)","title":"Util"},{"location":"examples/util/#deserialize-transaction","text":"require 'pp' require 'nem' # sender A_PRIVATE_KEY = '260206d683962350532408e8774fd14870a173b7fba17f6b504da3dbc5f1cc9f' # receiver B_ADDRESS = 'TAWKJTUP4DWKLDKKS534TYP6G324CBNMXKBA4X7B' kp = Nem::Keypair.new(A_PRIVATE_KEY) tx = Nem::Transaction::Transfer.new(B_ADDRESS, 1, 'Good luck!') req = Nem::Request::Announce.new(tx, kp) data = req.to_entity[:data] # You can also announce to nem Network later. pp data # deserialize data into hash hash = Nem::Util::Deserializer.deserialize(data) pp Nem::Model::Transaction.new_from_account_transaction(hash)","title":"Deserialize transaction"}]}